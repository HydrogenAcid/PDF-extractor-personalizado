<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Zipf + Shannon (PDF)</title>

  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Analizador de PDFs</h1>

  <form id="form" class="card">
    <div class="row">
      <input type="file" name="pdf" accept="application/pdf" required />
      <button type="submit">Subir y analizar</button>
      <button type="button" id="resetBtn" class="secondary">Reset</button>
    </div>
    <div class="hint">Sube PDFs uno por uno. Cada PDF se agrega a las gráficas con color distinto.</div>
  </form>

  <section class="card">
    <div class="sectionHeader">
      <h2>Zipf: Rango vs Frecuencia (log-log)</h2>
      <div class="small">Pendiente: ajuste lineal en log(rank) vs log(freq) con ranks [1..300]</div>
    </div>
    <canvas id="zipfChart"></canvas>

    <h3>Tabla (Zipf)</h3>
    <div class="tableWrap">
      <table id="zipfTable">
        <thead>
          <tr>
            <th>PDF</th>
            <th>Páginas</th>
            <th>Tokens</th>
            <th>Vocab</th>
            <th>Zipf slope</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <div class="sectionHeader">
      <h2>Longitud de palabra vs Frecuencia</h2>
      <div class="small">Distribución por longitudes agregando frecuencias por palabra</div>
    </div>
    <canvas id="lenChart"></canvas>

    <h3>Tabla (Longitudes)</h3>
    <div class="tableWrap">
      <table id="lenTable">
        <thead>
          <tr>
            <th>PDF</th>
            <th>Shannon H (nats)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

<script>
  const palette = [
    "#4f46e5","#ef4444","#10b981","#f59e0b","#06b6d4","#8b5cf6",
    "#22c55e","#e11d48","#0ea5e9","#a3e635","#f97316","#14b8a6"
  ];
  let colorIdx = 0;

  let zipfChart = null;
  let lenChart = null;

  const zipfDatasets = [];
  const lenDatasets = [];

  function nextColor() {
    const c = palette[colorIdx % palette.length];
    colorIdx++;
    return c;
  }

  function ensureCharts() {
    if (!zipfChart) {
      zipfChart = new Chart(document.getElementById("zipfChart"), {
        type: "scatter",
        data: { datasets: zipfDatasets },
        options: {
          responsive: true,
          scales: {
            x: { type: "logarithmic", title: { display: true, text: "Rango" } },
            y: { type: "logarithmic", title: { display: true, text: "Frecuencia" } }
          },
          plugins: { legend: { position: "bottom" } }
        }
      });
    }
    if (!lenChart) {
      lenChart = new Chart(document.getElementById("lenChart"), {
        type: "line",
        data: { datasets: lenDatasets },
        options: {
          responsive: true,
          scales: {
            x: { 
              type: "linear",
        min: 1,
        max: 23,
        ticks: { stepSize: 1 },
        title: { display: true, text: "Longitud" }
            },
            y: { title: { display: true, text: "Frecuencia" } }
          },
          plugins: { legend: { position: "bottom" } },
          elements: { point: { radius: 2 } }
        }
      });
    }
  }

  function addZipfRow(d) {
    const tb = document.querySelector("#zipfTable tbody");
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${escapeHtml(d.name)}</td>
      <td>${d.meta.pages}</td>
      <td>${d.meta.tokens}</td>
      <td>${d.meta.vocab}</td>
      <td>${fmt(d.zipf.slope)}</td>
    `;
    tb.appendChild(tr);
  }

  function addLenRow(d) {
    const tb = document.querySelector("#lenTable tbody");
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${escapeHtml(d.name)}</td>
      <td>${fmt(d.lengths.shannon_entropy_nats)}</td>
    `;
    tb.appendChild(tr);
  }

  function fmt(x) {
    if (x === null || x === undefined || Number.isNaN(x)) return "-";
    return Number(x).toFixed(6);
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"
    }[m]));
  }

  document.getElementById("form").addEventListener("submit", async (e) => {
    e.preventDefault();
    ensureCharts();

    const fd = new FormData(e.target);
    const r = await fetch("/process", { method: "POST", body: fd });
    const d = await r.json();
    if (d.error) { alert(d.error); return; }

    const color = nextColor();

    // Zipf dataset (scatter con log scales)
    const zipfPts = d.zipf.ranks.map((rk, i) => ({ x: rk, y: d.zipf.freqs[i] }));
    zipfDatasets.push({
      label: d.name,
      data: zipfPts,
      showLine: false,
      pointRadius: 2,
      borderColor: color,
      backgroundColor: color
    });

    // Longitudes dataset (line)
    const lenPts = d.lengths.x.map((L, i) => ({ x: L, y: d.lengths.freqs[i] }));
    lenDatasets.push({
      label: d.name,
      data: lenPts,
      borderColor: color,
      backgroundColor: color,
      tension: 0.1
    });

    zipfChart.update();
    lenChart.update();

    addZipfRow(d);
    addLenRow(d);

    // limpia el input para poder subir el mismo archivo si quieres
    e.target.reset();
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    zipfDatasets.length = 0;
    lenDatasets.length = 0;
    colorIdx = 0;

    const ztb = document.querySelector("#zipfTable tbody");
    const ltb = document.querySelector("#lenTable tbody");
    ztb.innerHTML = "";
    ltb.innerHTML = "";

    if (zipfChart) zipfChart.update();
    if (lenChart) lenChart.update();
  });
</script>
</body>
</html>